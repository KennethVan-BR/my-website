<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Installed Product Lookup with Search & Column Filters</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    input { padding: 8px; width: 100%; max-width: 400px; margin-bottom: 10px; }
    table { border-collapse: collapse; width: 100%; margin-bottom: 10px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background-color: #f9f9f9; }
    .pagination { margin-top: 10px; }
    .pagination button {
      padding: 6px 12px;
      margin-right: 5px;
      cursor: pointer;
    }
    .disabled { opacity: 0.5; pointer-events: none; }
    .filter-row { background-color: #f0f0f0; }
    .filter-row select { padding: 8px; width: 100%; }
    .filter-cell { padding: 5px; }
  </style>
</head>
<body>
  <h2>Installed Product Lookup with Search & Column Filters</h2>
  <input type="text" id="search" placeholder="Search across all columns..." />
  <table id="excelTable">
    <thead id="tableHead"></thead>
    <tbody id="tableBody"></tbody>
  </table>
  <div class="pagination">
    <button id="prevPage">Previous</button>
    <span id="pageInfo"></span>
    <button id="nextPage">Next</button>
  </div>

  <script>
    const fileUrl = "https://raw.githubusercontent.com/KennethVan-BR/InstalledProducts/main/Installed%20Product%20Lookup.xlsm";
    let fullData = [];
    let headers = [];
    let currentPage = 1;
    const rowsPerPage = 25;
    let filteredData = [];

    const tableHead = document.getElementById("tableHead");
    const tableBody = document.getElementById("tableBody");
    const searchInput = document.getElementById("search");
    const prevBtn = document.getElementById("prevPage");
    const nextBtn = document.getElementById("nextPage");
    const pageInfo = document.getElementById("pageInfo");

    let searchTimeout;

    fetch(fileUrl)
      .then(response => response.arrayBuffer())
      .then(data => {
        const workbook = XLSX.read(data, { type: 'array' });
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        headers = jsonData[0];
        fullData = jsonData.slice(1).map(row => processRow(row));
        filteredData = fullData;

        renderTableHead();
        renderTable();

        searchInput.addEventListener("input", debounce(() => {
          currentPage = 1; // Reset to page 1 on new search
          filterData(); // Apply the search filter
          renderFilters(); // Re-render filters based on search results
          renderTable();
        }, 500)); // Delay the search filter by 500ms

        prevBtn.addEventListener("click", () => {
          if (currentPage > 1) {
            currentPage--;
            renderTable();
          }
        });

        nextBtn.addEventListener("click", () => {
          if (currentPage < getTotalPages()) {
            currentPage++;
            renderTable();
          }
        });
      });

    function debounce(func, delay) {
      return function() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(func, delay);
      };
    }

    function processRow(row) {
      row.forEach((cell, index) => {
        if (isDateColumn(headers[index])) {
          row[index] = convertExcelSerialDate(cell);
        }
      });
      return row;
    }

    function renderTableHead() {
      tableHead.innerHTML = "";

      // Render Filter Row
      const filterRow = document.createElement("tr");
      filterRow.classList.add("filter-row");

      headers.forEach((header, index) => {
        const filterCell = document.createElement("th");
        filterCell.classList.add("filter-cell");

        const select = document.createElement("select");
        const defaultOption = document.createElement("option");
        defaultOption.textContent = `Filter by ${header}`;
        defaultOption.value = "";
        select.appendChild(defaultOption);

        // Filter only based on currently filtered data
        const uniqueValues = [...new Set(filteredData.map(row => row[index]))].sort();
        uniqueValues.forEach(value => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = value;
          select.appendChild(option);
        });

        select.addEventListener("change", () => {
          currentPage = 1; // Reset to page 1 on filter change
          filterData();
          renderTable();
        });

        filterCell.appendChild(select);
        filterRow.appendChild(filterCell);
      });

      tableHead.appendChild(filterRow);

      // Render Table Header Row
      const headerRow = document.createElement("tr");
      headers.forEach(header => {
        const th = document.createElement("th");
        th.textContent = header;
        headerRow.appendChild(th);
      });
      tableHead.appendChild(headerRow);
    }

    function renderTable() {
      const totalPages = Math.ceil(filteredData.length / rowsPerPage);
      const start = (currentPage - 1) * rowsPerPage;
      const end = start + rowsPerPage;

      const paginatedRows = filteredData.slice(start, end);

      tableBody.innerHTML = "";
      const fragment = document.createDocumentFragment(); // Batch updates using fragment
      paginatedRows.forEach(row => {
        const tr = document.createElement("tr");
        row.forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell !== undefined ? cell : "";
          tr.appendChild(td);
        });
        fragment.appendChild(tr);
      });
      tableBody.appendChild(fragment); // Append all rows at once

      pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      prevBtn.classList.toggle("disabled", currentPage === 1);
      nextBtn.classList.toggle("disabled", currentPage === totalPages || totalPages === 0);
    }

    function renderFilters() {
      // Re-render the filter row based on the current filtered data
      const filterRow = tableHead.querySelector(".filter-row");
      if (!filterRow) return;

      const selectElements = filterRow.querySelectorAll("select");
      selectElements.forEach((select, index) => {
        // Clear existing options
        select.innerHTML = '';
        const defaultOption = document.createElement("option");
        defaultOption.textContent = `Filter by ${headers[index]}`;
        defaultOption.value = "";
        select.appendChild(defaultOption);

        // Get unique values from the filtered data for the column
        const uniqueValues = [...new Set(filteredData.map(row => row[index]))].sort();
        uniqueValues.forEach(value => {
          const option = document.createElement("option");
          option.value = value;
          option.textContent = value;
          select.appendChild(option);
        });
      });
    }

    function filterData() {
      const query = searchInput.value.toLowerCase();
      filteredData = fullData.filter(row =>
        row.join(" ").toLowerCase().includes(query) // Search across all columns
      );

      // Apply column-specific filters
      const filterValues = Array.from(tableHead.querySelectorAll("select")).map(select => select.value);

      filteredData = filteredData.filter(row =>
        row.every((cell, index) => {
          const filterValue = filterValues[index];
          return filterValue ? cell === filterValue : true;
        })
      );
    }

    function getTotalPages() {
      return Math.ceil(filteredData.length / rowsPerPage);
    }

    function isDateColumn(header) {
      // Modify these to match the actual column headers for "Date Installed" and "Date Shipped"
      const dateColumns = ["Date Installed", "Date Shipped"];
      return dateColumns.includes(header);
    }

    function convertExcelSerialDate(serial) {
      if (serial === null || serial === undefined) return "";
      const excelEpoch = new Date(1899, 11, 30); // Excel's starting date is 1899-12-30
      const date = new Date(excelEpoch.getTime() + serial * 86400000); // Multiply by milliseconds per day
      const mm = ('0' + (date.getMonth() + 1)).slice(-2); // Months are 0-based
      const dd = ('0' + date.getDate()).slice(-2);
      const yyyy = date.getFullYear();
      return `${mm}/${dd}/${yyyy}`;
    }
  </script>
</body>
</html>
